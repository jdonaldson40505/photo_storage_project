{"message":"unused import: `std::error::Error`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\lib.rs","byte_start":121,"byte_end":138,"line_start":6,"line_end":6,"column_start":5,"column_end":22,"is_primary":true,"text":[{"text":"use std::error::Error;","highlight_start":5,"highlight_end":22}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":117,"byte_end":139,"line_start":6,"line_end":6,"column_start":1,"column_end":23,"is_primary":true,"text":[{"text":"use std::error::Error;","highlight_start":1,"highlight_end":23}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `std::error::Error`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:6:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0muse std::error::Error;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused import: `futures`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src\\lib.rs","byte_start":2830,"byte_end":2837,"line_start":103,"line_end":103,"column_start":9,"column_end":16,"is_primary":true,"text":[{"text":"    use futures;","highlight_start":9,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":2826,"byte_end":2838,"line_start":103,"line_end":103,"column_start":5,"column_end":17,"is_primary":true,"text":[{"text":"    use futures;","highlight_start":5,"highlight_end":17}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `futures`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:103:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m103\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    use futures;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^\u001b[0m\n\n"}
{"message":"mismatched types","code":{"code":"E0308","explanation":"This error occurs when the compiler was unable to infer the concrete type of a\nvariable. It can occur for several cases, the most common of which is a\nmismatch in the expected type that the compiler inferred for a variable's\ninitializing expression, and the actual type explicitly assigned to the\nvariable.\n\nFor example:\n\n```compile_fail,E0308\nlet x: i32 = \"I am not a number!\";\n//     ~~~   ~~~~~~~~~~~~~~~~~~~~\n//      |             |\n//      |    initializing expression;\n//      |    compiler infers type `&str`\n//      |\n//    type `i32` assigned to variable `x`\n```\n"},"level":"error","spans":[{"file_name":"<::core::macros::assert_eq macros>","byte_start":156,"byte_end":167,"line_start":7,"line_end":7,"column_start":34,"column_end":45,"is_primary":true,"text":[{"text":"             if ! (* left_val == * right_val)","highlight_start":34,"highlight_end":45}],"label":"expected enum `std::option::Option`, found struct `UserData`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\lib.rs","byte_start":6498,"byte_end":6565,"line_start":202,"line_end":202,"column_start":9,"column_end":76,"is_primary":false,"text":[{"text":"        assert_eq!(get_user(\"Jdonaldson40505\", \"joshua12309\").await, info);","highlight_start":9,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"<::core::macros::assert_eq macros>","byte_start":0,"byte_end":940,"line_start":1,"line_end":36,"column_start":1,"column_end":6,"is_primary":false,"text":[{"text":"($ left : expr, $ right : expr) =>","highlight_start":1,"highlight_end":35},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     match (& $ left, & $ right)","highlight_start":1,"highlight_end":33},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         (left_val, right_val) =>","highlight_start":1,"highlight_end":34},{"text":"         {","highlight_start":1,"highlight_end":11},{"text":"             if ! (* left_val == * right_val)","highlight_start":1,"highlight_end":46},{"text":"             {","highlight_start":1,"highlight_end":15},{"text":"                 panic !","highlight_start":1,"highlight_end":25},{"text":"                 (r#\"assertion failed: `(left == right)`","highlight_start":1,"highlight_end":57},{"text":"  left: `{:?}`,","highlight_start":1,"highlight_end":16},{"text":" right: `{:?}`\"#,","highlight_start":1,"highlight_end":18},{"text":"                  & * left_val, & * right_val)","highlight_start":1,"highlight_end":47},{"text":"             }","highlight_start":1,"highlight_end":15},{"text":"         }","highlight_start":1,"highlight_end":11},{"text":"     }","highlight_start":1,"highlight_end":7},{"text":" }) ; ($ left : expr, $ right : expr,) =>","highlight_start":1,"highlight_end":42},{"text":"({ $ crate :: assert_eq ! ($ left, $ right) }) ;","highlight_start":1,"highlight_end":49},{"text":"($ left : expr, $ right : expr, $ ($ arg : tt) +) =>","highlight_start":1,"highlight_end":53},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     match (& ($ left), & ($ right))","highlight_start":1,"highlight_end":37},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         (left_val, right_val) =>","highlight_start":1,"highlight_end":34},{"text":"         {","highlight_start":1,"highlight_end":11},{"text":"             if ! (* left_val == * right_val)","highlight_start":1,"highlight_end":46},{"text":"             {","highlight_start":1,"highlight_end":15},{"text":"                 panic !","highlight_start":1,"highlight_end":25},{"text":"                 (r#\"assertion failed: `(left == right)`","highlight_start":1,"highlight_end":57},{"text":"  left: `{:?}`,","highlight_start":1,"highlight_end":16},{"text":" right: `{:?}`: {}\"#,","highlight_start":1,"highlight_end":22},{"text":"                  & * left_val, & * right_val, $ crate :: format_args !","highlight_start":1,"highlight_end":72},{"text":"                  ($ ($ arg) +))","highlight_start":1,"highlight_end":33},{"text":"             }","highlight_start":1,"highlight_end":15},{"text":"         }","highlight_start":1,"highlight_end":11},{"text":"     }","highlight_start":1,"highlight_end":7},{"text":" }) ;","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"expected enum `std::option::Option<UserData>`\n found struct `UserData`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"try using a variant of the expected enum","code":null,"level":"help","spans":[{"file_name":"<::core::macros::assert_eq macros>","byte_start":156,"byte_end":167,"line_start":7,"line_end":7,"column_start":34,"column_end":45,"is_primary":true,"text":[{"text":"             if ! (* left_val == * right_val)","highlight_start":34,"highlight_end":45}],"label":null,"suggested_replacement":"Some(* right_val)","suggestion_applicability":"MaybeIncorrect","expansion":{"span":{"file_name":"src\\lib.rs","byte_start":6498,"byte_end":6565,"line_start":202,"line_end":202,"column_start":9,"column_end":76,"is_primary":false,"text":[{"text":"        assert_eq!(get_user(\"Jdonaldson40505\", \"joshua12309\").await, info);","highlight_start":9,"highlight_end":76}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"assert_eq!","def_site_span":{"file_name":"<::core::macros::assert_eq macros>","byte_start":0,"byte_end":940,"line_start":1,"line_end":36,"column_start":1,"column_end":6,"is_primary":false,"text":[{"text":"($ left : expr, $ right : expr) =>","highlight_start":1,"highlight_end":35},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     match (& $ left, & $ right)","highlight_start":1,"highlight_end":33},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         (left_val, right_val) =>","highlight_start":1,"highlight_end":34},{"text":"         {","highlight_start":1,"highlight_end":11},{"text":"             if ! (* left_val == * right_val)","highlight_start":1,"highlight_end":46},{"text":"             {","highlight_start":1,"highlight_end":15},{"text":"                 panic !","highlight_start":1,"highlight_end":25},{"text":"                 (r#\"assertion failed: `(left == right)`","highlight_start":1,"highlight_end":57},{"text":"  left: `{:?}`,","highlight_start":1,"highlight_end":16},{"text":" right: `{:?}`\"#,","highlight_start":1,"highlight_end":18},{"text":"                  & * left_val, & * right_val)","highlight_start":1,"highlight_end":47},{"text":"             }","highlight_start":1,"highlight_end":15},{"text":"         }","highlight_start":1,"highlight_end":11},{"text":"     }","highlight_start":1,"highlight_end":7},{"text":" }) ; ($ left : expr, $ right : expr,) =>","highlight_start":1,"highlight_end":42},{"text":"({ $ crate :: assert_eq ! ($ left, $ right) }) ;","highlight_start":1,"highlight_end":49},{"text":"($ left : expr, $ right : expr, $ ($ arg : tt) +) =>","highlight_start":1,"highlight_end":53},{"text":"({","highlight_start":1,"highlight_end":3},{"text":"     match (& ($ left), & ($ right))","highlight_start":1,"highlight_end":37},{"text":"     {","highlight_start":1,"highlight_end":7},{"text":"         (left_val, right_val) =>","highlight_start":1,"highlight_end":34},{"text":"         {","highlight_start":1,"highlight_end":11},{"text":"             if ! (* left_val == * right_val)","highlight_start":1,"highlight_end":46},{"text":"             {","highlight_start":1,"highlight_end":15},{"text":"                 panic !","highlight_start":1,"highlight_end":25},{"text":"                 (r#\"assertion failed: `(left == right)`","highlight_start":1,"highlight_end":57},{"text":"  left: `{:?}`,","highlight_start":1,"highlight_end":16},{"text":" right: `{:?}`: {}\"#,","highlight_start":1,"highlight_end":22},{"text":"                  & * left_val, & * right_val, $ crate :: format_args !","highlight_start":1,"highlight_end":72},{"text":"                  ($ ($ arg) +))","highlight_start":1,"highlight_end":33},{"text":"             }","highlight_start":1,"highlight_end":15},{"text":"         }","highlight_start":1,"highlight_end":11},{"text":"     }","highlight_start":1,"highlight_end":7},{"text":" }) ;","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0308]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: mismatched types\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:202:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m202\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        assert_eq!(get_user(\"Jdonaldson40505\", \"joshua12309\").await, info);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mexpected enum `std::option::Option`, found struct `UserData`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mhelp: try using a variant of the expected enum: `Some(* right_val)`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: expected enum `\u001b[0m\u001b[0m\u001b[1mstd::option::Option<\u001b[0m\u001b[0mUserData\u001b[0m\u001b[0m\u001b[1m>\u001b[0m\u001b[0m`\u001b[0m\n\u001b[0m             found struct `UserData`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to previous error\u001b[0m\n\n"}
{"message":"For more information about this error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about this error, try `rustc --explain E0308`.\u001b[0m\n"}
