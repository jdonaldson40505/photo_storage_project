{"message":"failed to resolve: use of undeclared type or module `futures`","code":{"code":"E0433","explanation":"An undeclared type or module was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type or module `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":61,"byte_end":68,"line_start":3,"line_end":3,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"use futures::lock::Mutex;","highlight_start":5,"highlight_end":12}],"label":"use of undeclared type or module `futures`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared type or module `futures`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:3:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m3\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0muse futures::lock::Mutex;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type or module `futures`\u001b[0m\n\n"}
{"message":"unresolved import `futures`","code":{"code":"E0432","explanation":"An import was unresolved.\n\nErroneous code example:\n\n```compile_fail,E0432\nuse something::Foo; // error: unresolved import `something::Foo`.\n```\n\nPaths in `use` statements are relative to the crate root. To import items\nrelative to the current and parent modules, use the `self::` and `super::`\nprefixes, respectively. Also verify that you didn't misspell the import\nname and that the import exists in the module from where you tried to\nimport it. Example:\n\n```\nuse self::something::Foo; // ok!\n\nmod something {\n    pub struct Foo;\n}\n# fn main() {}\n```\n\nOr, if you tried to use a module from an external crate, you may have missed\nthe `extern crate` declaration (which is usually placed in the crate root):\n\n```\nextern crate core; // Required to use the `core` crate\n\nuse core::any;\n# fn main() {}\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":108,"byte_end":115,"line_start":5,"line_end":5,"column_start":5,"column_end":12,"is_primary":true,"text":[{"text":"use futures;","highlight_start":5,"highlight_end":12}],"label":"no `futures` external crate","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0432]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unresolved import `futures`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:5:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0muse futures;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mno `futures` external crate\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type or module `Mutex`","code":{"code":"E0433","explanation":"An undeclared type or module was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type or module `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":525,"byte_end":530,"line_start":17,"line_end":17,"column_start":58,"column_end":63,"is_primary":true,"text":[{"text":"    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());","highlight_start":58,"highlight_end":63}],"label":"use of undeclared type or module `Mutex`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared type or module `Mutex`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:17:58\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type or module `Mutex`\u001b[0m\n\n"}
{"message":"failed to resolve: use of undeclared type or module `Mutex`","code":{"code":"E0433","explanation":"An undeclared type or module was used.\n\nErroneous code example:\n\n```compile_fail,E0433\nlet map = HashMap::new();\n// error: failed to resolve: use of undeclared type or module `HashMap`\n```\n\nPlease verify you didn't misspell the type/module's name or that you didn't\nforget to import it:\n\n\n```\nuse std::collections::HashMap; // HashMap has been imported.\nlet map: HashMap<u32, u32> = HashMap::new(); // So it can be used!\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":626,"byte_end":631,"line_start":18,"line_end":18,"column_start":74,"column_end":79,"is_primary":true,"text":[{"text":"    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());","highlight_start":74,"highlight_end":79}],"label":"use of undeclared type or module `Mutex`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0433]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: failed to resolve: use of undeclared type or module `Mutex`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:18:74\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                                                         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9muse of undeclared type or module `Mutex`\u001b[0m\n\n"}
{"message":"cannot find type `Mutex` in this scope","code":{"code":"E0412","explanation":"The type name used is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":490,"byte_end":495,"line_start":17,"line_end":17,"column_start":23,"column_end":28,"is_primary":true,"text":[{"text":"    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());","highlight_start":23,"highlight_end":28}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"possible candidates are found in other modules, you can import them into scope","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use std::sync::Mutex;\n","suggestion_applicability":"Unspecified","expansion":null},{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use tokio::sync::Mutex;\n","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `Mutex` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:17:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: possible candidates are found in other modules, you can import them into scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0muse std::sync::Mutex;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0muse tokio::sync::Mutex;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\n"}
{"message":"cannot find type `Mutex` in this scope","code":{"code":"E0412","explanation":"The type name used is not in scope.\n\nErroneous code examples:\n\n```compile_fail,E0412\nimpl Something {} // error: type name `Something` is not in scope\n\n// or:\n\ntrait Foo {\n    fn bar(N); // error: type name `N` is not in scope\n}\n\n// or:\n\nfn foo(x: T) {} // type name `T` is not in scope\n```\n\nTo fix this error, please verify you didn't misspell the type name, you did\ndeclare it or imported it into the scope. Examples:\n\n```\nstruct Something;\n\nimpl Something {} // ok!\n\n// or:\n\ntrait Foo {\n    type N;\n\n    fn bar(_: Self::N); // ok!\n}\n\n// or:\n\nfn foo<T>(x: T) {} // ok!\n```\n\nAnother case that causes this error is when a type is imported into a parent\nmodule. To fix this, you can follow the suggestion and use File directly or\n`use super::File;` which will import the types from the parent namespace. An\nexample that causes this error is below:\n\n```compile_fail,E0412\nuse std::fs::File;\n\nmod foo {\n    fn some_function(f: File) {}\n}\n```\n\n```\nuse std::fs::File;\n\nmod foo {\n    // either\n    use super::File;\n    // or\n    // use std::fs::File;\n    fn foo(f: File) {}\n}\n# fn main() {} // don't insert it for us; that'll break imports\n```\n"},"level":"error","spans":[{"file_name":"src\\lib.rs","byte_start":576,"byte_end":581,"line_start":18,"line_end":18,"column_start":24,"column_end":29,"is_primary":true,"text":[{"text":"    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());","highlight_start":24,"highlight_end":29}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"possible candidates are found in other modules, you can import them into scope","code":null,"level":"help","spans":[{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use std::sync::Mutex;\n","suggestion_applicability":"Unspecified","expansion":null},{"file_name":"src\\lib.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":true,"text":[{"text":"use std::collections::HashMap;","highlight_start":1,"highlight_end":1}],"label":null,"suggested_replacement":"use tokio::sync::Mutex;\n","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0412]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: cannot find type `Mutex` in this scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:18:24\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mnot found in this scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: possible candidates are found in other modules, you can import them into scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0muse std::sync::Mutex;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0muse tokio::sync::Mutex;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\n"}
{"message":"no method named `lock` found for struct `PHOTOS` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n"},"level":"error","spans":[{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":1066,"byte_end":1076,"line_start":25,"line_end":25,"column_start":56,"column_end":66,"is_primary":false,"text":[{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":56,"highlight_end":66}],"label":"method `lock` not found for this","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":119,"byte_end":199,"line_start":4,"line_end":5,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":5,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::lazy_static::lazy_static macros>","byte_start":100,"byte_end":191,"line_start":4,"line_end":5,"column_start":5,"column_end":67,"is_primary":false,"text":[{"text":"    __lazy_static_internal !","highlight_start":5,"highlight_end":29},{"text":"    ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":253,"byte_end":284,"line_start":5,"line_end":6,"column_start":60,"column_end":18,"is_primary":false,"text":[{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":60,"highlight_end":73},{"text":"    ($ ($ t) *) ;","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\lib.rs","byte_start":440,"byte_end":655,"line_start":16,"line_end":19,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"lazy_static::lazy_static! {","highlight_start":1,"highlight_end":28},{"text":"    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());","highlight_start":1,"highlight_end":85},{"text":"    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());","highlight_start":1,"highlight_end":101},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"lazy_static::lazy_static!","def_site_span":{"file_name":"<::lazy_static::lazy_static macros>","byte_start":0,"byte_end":648,"line_start":1,"line_end":19,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * static ref $ N : ident : $ T : ty = $ e : expr ; $","highlight_start":1,"highlight_end":76},{"text":" ($ t : tt) *) =>","highlight_start":1,"highlight_end":18},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":67},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub static ref $ N : ident : $ T : ty = $ e : expr ;","highlight_start":1,"highlight_end":78},{"text":" $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":20},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub) static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":70},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub ($ ($ vis : tt) +) static ref $ N : ident : $ T :","highlight_start":1,"highlight_end":79},{"text":" ty = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":38},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub ($ ($ vis) +)) static ref $ N : $ T = $ e ; $ ($ t)","highlight_start":1,"highlight_end":79},{"text":"     *) ;","highlight_start":1,"highlight_end":10},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"lazy_static!","def_site_span":{"file_name":"<::lazy_static::lazy_static macros>","byte_start":0,"byte_end":648,"line_start":1,"line_end":19,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * static ref $ N : ident : $ T : ty = $ e : expr ; $","highlight_start":1,"highlight_end":76},{"text":" ($ t : tt) *) =>","highlight_start":1,"highlight_end":18},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":67},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub static ref $ N : ident : $ T : ty = $ e : expr ;","highlight_start":1,"highlight_end":78},{"text":" $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":20},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub) static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":70},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub ($ ($ vis : tt) +) static ref $ N : ident : $ T :","highlight_start":1,"highlight_end":79},{"text":" ty = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":38},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub ($ ($ vis) +)) static ref $ N : $ T = $ e ; $ ($ t)","highlight_start":1,"highlight_end":79},{"text":"     *) ;","highlight_start":1,"highlight_end":10},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"__lazy_static_internal!","def_site_span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":0,"byte_end":1201,"line_start":1,"line_end":28,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ($ ($ vis : tt) *) static ref $ N : ident : $ T : ty","highlight_start":1,"highlight_end":78},{"text":" = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":1,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":73},{"text":"    ($ ($ t) *) ;","highlight_start":1,"highlight_end":18},{"text":"} ; (@ TAIL, $ N : ident : $ T : ty = $ e : expr) =>","highlight_start":1,"highlight_end":53},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    impl $ crate :: __Deref for $ N","highlight_start":1,"highlight_end":36},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        type Target = $ T ; fn deref (& self) -> & $ T","highlight_start":1,"highlight_end":55},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            # [inline (always)] fn __static_ref_initialize () -> $ T { $ e } #","highlight_start":1,"highlight_end":79},{"text":"            [inline (always)] fn __stability () -> & 'static $ T","highlight_start":1,"highlight_end":65},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                __lazy_static_create ! (LAZY, $ T) ; LAZY . get","highlight_start":1,"highlight_end":64},{"text":"                (__static_ref_initialize)","highlight_start":1,"highlight_end":42},{"text":"            } __stability ()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } impl $ crate :: LazyStatic for $ N","highlight_start":1,"highlight_end":41},{"text":"    { fn initialize (lazy : & Self) { let _ = & * * lazy ; } }","highlight_start":1,"highlight_end":63},{"text":"} ; (@ MAKE TY, $ (# [$ attr : meta]) *, ($ ($ vis : tt) *), $ N : ident) =>","highlight_start":1,"highlight_end":77},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    # [allow (missing_copy_implementations)] # [allow (non_camel_case_types)]","highlight_start":1,"highlight_end":78},{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":1,"highlight_end":66},{"text":"    { __private_field : () } # [doc (hidden)] $ ($ vis) * static $ N : $ N = $","highlight_start":1,"highlight_end":79},{"text":"    N { __private_field : () } ;","highlight_start":1,"highlight_end":33},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"__lazy_static_internal!","def_site_span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":0,"byte_end":1201,"line_start":1,"line_end":28,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ($ ($ vis : tt) *) static ref $ N : ident : $ T : ty","highlight_start":1,"highlight_end":78},{"text":" = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":1,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":73},{"text":"    ($ ($ t) *) ;","highlight_start":1,"highlight_end":18},{"text":"} ; (@ TAIL, $ N : ident : $ T : ty = $ e : expr) =>","highlight_start":1,"highlight_end":53},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    impl $ crate :: __Deref for $ N","highlight_start":1,"highlight_end":36},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        type Target = $ T ; fn deref (& self) -> & $ T","highlight_start":1,"highlight_end":55},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            # [inline (always)] fn __static_ref_initialize () -> $ T { $ e } #","highlight_start":1,"highlight_end":79},{"text":"            [inline (always)] fn __stability () -> & 'static $ T","highlight_start":1,"highlight_end":65},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                __lazy_static_create ! (LAZY, $ T) ; LAZY . get","highlight_start":1,"highlight_end":64},{"text":"                (__static_ref_initialize)","highlight_start":1,"highlight_end":42},{"text":"            } __stability ()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } impl $ crate :: LazyStatic for $ N","highlight_start":1,"highlight_end":41},{"text":"    { fn initialize (lazy : & Self) { let _ = & * * lazy ; } }","highlight_start":1,"highlight_end":63},{"text":"} ; (@ MAKE TY, $ (# [$ attr : meta]) *, ($ ($ vis : tt) *), $ N : ident) =>","highlight_start":1,"highlight_end":77},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    # [allow (missing_copy_implementations)] # [allow (non_camel_case_types)]","highlight_start":1,"highlight_end":78},{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":1,"highlight_end":66},{"text":"    { __private_field : () } # [doc (hidden)] $ ($ vis) * static $ N : $ N = $","highlight_start":1,"highlight_end":79},{"text":"    N { __private_field : () } ;","highlight_start":1,"highlight_end":33},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\lib.rs","byte_start":1258,"byte_end":1262,"line_start":44,"line_end":44,"column_start":25,"column_end":29,"is_primary":true,"text":[{"text":"    let photos = PHOTOS.lock().await;","highlight_start":25,"highlight_end":29}],"label":"method not found in `PHOTOS`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait defines an item `lock`, perhaps you need to implement it:\ncandidate #1: `lock_api::RawMutex`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: no method named `lock` found for struct `PHOTOS` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:44:25\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mlazy_static::lazy_static! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mmethod `lock` not found for this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m44\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    let photos = PHOTOS.lock().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `PHOTOS`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is implemented and in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: the following trait defines an item `lock`, perhaps you need to implement it:\u001b[0m\n\u001b[0m           candidate #1: `lock_api::RawMutex`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"no method named `lock` found for struct `PHOTOS` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n"},"level":"error","spans":[{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":1066,"byte_end":1076,"line_start":25,"line_end":25,"column_start":56,"column_end":66,"is_primary":false,"text":[{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":56,"highlight_end":66}],"label":"method `lock` not found for this","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":119,"byte_end":199,"line_start":4,"line_end":5,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":5,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::lazy_static::lazy_static macros>","byte_start":100,"byte_end":191,"line_start":4,"line_end":5,"column_start":5,"column_end":67,"is_primary":false,"text":[{"text":"    __lazy_static_internal !","highlight_start":5,"highlight_end":29},{"text":"    ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":253,"byte_end":284,"line_start":5,"line_end":6,"column_start":60,"column_end":18,"is_primary":false,"text":[{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":60,"highlight_end":73},{"text":"    ($ ($ t) *) ;","highlight_start":1,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\lib.rs","byte_start":440,"byte_end":655,"line_start":16,"line_end":19,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"lazy_static::lazy_static! {","highlight_start":1,"highlight_end":28},{"text":"    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());","highlight_start":1,"highlight_end":85},{"text":"    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());","highlight_start":1,"highlight_end":101},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"lazy_static::lazy_static!","def_site_span":{"file_name":"<::lazy_static::lazy_static macros>","byte_start":0,"byte_end":648,"line_start":1,"line_end":19,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * static ref $ N : ident : $ T : ty = $ e : expr ; $","highlight_start":1,"highlight_end":76},{"text":" ($ t : tt) *) =>","highlight_start":1,"highlight_end":18},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":67},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub static ref $ N : ident : $ T : ty = $ e : expr ;","highlight_start":1,"highlight_end":78},{"text":" $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":20},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub) static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":70},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub ($ ($ vis : tt) +) static ref $ N : ident : $ T :","highlight_start":1,"highlight_end":79},{"text":" ty = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":38},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub ($ ($ vis) +)) static ref $ N : $ T = $ e ; $ ($ t)","highlight_start":1,"highlight_end":79},{"text":"     *) ;","highlight_start":1,"highlight_end":10},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"lazy_static!","def_site_span":{"file_name":"<::lazy_static::lazy_static macros>","byte_start":0,"byte_end":648,"line_start":1,"line_end":19,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * static ref $ N : ident : $ T : ty = $ e : expr ; $","highlight_start":1,"highlight_end":76},{"text":" ($ t : tt) *) =>","highlight_start":1,"highlight_end":18},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":67},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub static ref $ N : ident : $ T : ty = $ e : expr ;","highlight_start":1,"highlight_end":78},{"text":" $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":20},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub) static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":70},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub ($ ($ vis : tt) +) static ref $ N : ident : $ T :","highlight_start":1,"highlight_end":79},{"text":" ty = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":38},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub ($ ($ vis) +)) static ref $ N : $ T = $ e ; $ ($ t)","highlight_start":1,"highlight_end":79},{"text":"     *) ;","highlight_start":1,"highlight_end":10},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"__lazy_static_internal!","def_site_span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":0,"byte_end":1201,"line_start":1,"line_end":28,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ($ ($ vis : tt) *) static ref $ N : ident : $ T : ty","highlight_start":1,"highlight_end":78},{"text":" = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":1,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":73},{"text":"    ($ ($ t) *) ;","highlight_start":1,"highlight_end":18},{"text":"} ; (@ TAIL, $ N : ident : $ T : ty = $ e : expr) =>","highlight_start":1,"highlight_end":53},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    impl $ crate :: __Deref for $ N","highlight_start":1,"highlight_end":36},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        type Target = $ T ; fn deref (& self) -> & $ T","highlight_start":1,"highlight_end":55},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            # [inline (always)] fn __static_ref_initialize () -> $ T { $ e } #","highlight_start":1,"highlight_end":79},{"text":"            [inline (always)] fn __stability () -> & 'static $ T","highlight_start":1,"highlight_end":65},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                __lazy_static_create ! (LAZY, $ T) ; LAZY . get","highlight_start":1,"highlight_end":64},{"text":"                (__static_ref_initialize)","highlight_start":1,"highlight_end":42},{"text":"            } __stability ()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } impl $ crate :: LazyStatic for $ N","highlight_start":1,"highlight_end":41},{"text":"    { fn initialize (lazy : & Self) { let _ = & * * lazy ; } }","highlight_start":1,"highlight_end":63},{"text":"} ; (@ MAKE TY, $ (# [$ attr : meta]) *, ($ ($ vis : tt) *), $ N : ident) =>","highlight_start":1,"highlight_end":77},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    # [allow (missing_copy_implementations)] # [allow (non_camel_case_types)]","highlight_start":1,"highlight_end":78},{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":1,"highlight_end":66},{"text":"    { __private_field : () } # [doc (hidden)] $ ($ vis) * static $ N : $ N = $","highlight_start":1,"highlight_end":79},{"text":"    N { __private_field : () } ;","highlight_start":1,"highlight_end":33},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"__lazy_static_internal!","def_site_span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":0,"byte_end":1201,"line_start":1,"line_end":28,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ($ ($ vis : tt) *) static ref $ N : ident : $ T : ty","highlight_start":1,"highlight_end":78},{"text":" = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":1,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":73},{"text":"    ($ ($ t) *) ;","highlight_start":1,"highlight_end":18},{"text":"} ; (@ TAIL, $ N : ident : $ T : ty = $ e : expr) =>","highlight_start":1,"highlight_end":53},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    impl $ crate :: __Deref for $ N","highlight_start":1,"highlight_end":36},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        type Target = $ T ; fn deref (& self) -> & $ T","highlight_start":1,"highlight_end":55},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            # [inline (always)] fn __static_ref_initialize () -> $ T { $ e } #","highlight_start":1,"highlight_end":79},{"text":"            [inline (always)] fn __stability () -> & 'static $ T","highlight_start":1,"highlight_end":65},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                __lazy_static_create ! (LAZY, $ T) ; LAZY . get","highlight_start":1,"highlight_end":64},{"text":"                (__static_ref_initialize)","highlight_start":1,"highlight_end":42},{"text":"            } __stability ()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } impl $ crate :: LazyStatic for $ N","highlight_start":1,"highlight_end":41},{"text":"    { fn initialize (lazy : & Self) { let _ = & * * lazy ; } }","highlight_start":1,"highlight_end":63},{"text":"} ; (@ MAKE TY, $ (# [$ attr : meta]) *, ($ ($ vis : tt) *), $ N : ident) =>","highlight_start":1,"highlight_end":77},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    # [allow (missing_copy_implementations)] # [allow (non_camel_case_types)]","highlight_start":1,"highlight_end":78},{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":1,"highlight_end":66},{"text":"    { __private_field : () } # [doc (hidden)] $ ($ vis) * static $ N : $ N = $","highlight_start":1,"highlight_end":79},{"text":"    N { __private_field : () } ;","highlight_start":1,"highlight_end":33},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\lib.rs","byte_start":1614,"byte_end":1618,"line_start":57,"line_end":57,"column_start":29,"column_end":33,"is_primary":true,"text":[{"text":"    let mut photos = PHOTOS.lock().await;","highlight_start":29,"highlight_end":33}],"label":"method not found in `PHOTOS`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait defines an item `lock`, perhaps you need to implement it:\ncandidate #1: `lock_api::RawMutex`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: no method named `lock` found for struct `PHOTOS` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:57:29\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mlazy_static::lazy_static! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mmethod `lock` not found for this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m57\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    let mut photos = PHOTOS.lock().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                              \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `PHOTOS`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is implemented and in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: the following trait defines an item `lock`, perhaps you need to implement it:\u001b[0m\n\u001b[0m           candidate #1: `lock_api::RawMutex`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"no method named `lock` found for struct `USERS` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n"},"level":"error","spans":[{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":1066,"byte_end":1076,"line_start":25,"line_end":25,"column_start":56,"column_end":66,"is_primary":false,"text":[{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":56,"highlight_end":66}],"label":"method `lock` not found for this","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":119,"byte_end":199,"line_start":4,"line_end":5,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":5,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::lazy_static::lazy_static macros>","byte_start":100,"byte_end":191,"line_start":4,"line_end":5,"column_start":5,"column_end":67,"is_primary":false,"text":[{"text":"    __lazy_static_internal !","highlight_start":5,"highlight_end":29},{"text":"    ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\lib.rs","byte_start":440,"byte_end":655,"line_start":16,"line_end":19,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"lazy_static::lazy_static! {","highlight_start":1,"highlight_end":28},{"text":"    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());","highlight_start":1,"highlight_end":85},{"text":"    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());","highlight_start":1,"highlight_end":101},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"lazy_static::lazy_static!","def_site_span":{"file_name":"<::lazy_static::lazy_static macros>","byte_start":0,"byte_end":648,"line_start":1,"line_end":19,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * static ref $ N : ident : $ T : ty = $ e : expr ; $","highlight_start":1,"highlight_end":76},{"text":" ($ t : tt) *) =>","highlight_start":1,"highlight_end":18},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":67},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub static ref $ N : ident : $ T : ty = $ e : expr ;","highlight_start":1,"highlight_end":78},{"text":" $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":20},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub) static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":70},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub ($ ($ vis : tt) +) static ref $ N : ident : $ T :","highlight_start":1,"highlight_end":79},{"text":" ty = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":38},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub ($ ($ vis) +)) static ref $ N : $ T = $ e ; $ ($ t)","highlight_start":1,"highlight_end":79},{"text":"     *) ;","highlight_start":1,"highlight_end":10},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"__lazy_static_internal!","def_site_span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":0,"byte_end":1201,"line_start":1,"line_end":28,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ($ ($ vis : tt) *) static ref $ N : ident : $ T : ty","highlight_start":1,"highlight_end":78},{"text":" = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":1,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":73},{"text":"    ($ ($ t) *) ;","highlight_start":1,"highlight_end":18},{"text":"} ; (@ TAIL, $ N : ident : $ T : ty = $ e : expr) =>","highlight_start":1,"highlight_end":53},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    impl $ crate :: __Deref for $ N","highlight_start":1,"highlight_end":36},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        type Target = $ T ; fn deref (& self) -> & $ T","highlight_start":1,"highlight_end":55},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            # [inline (always)] fn __static_ref_initialize () -> $ T { $ e } #","highlight_start":1,"highlight_end":79},{"text":"            [inline (always)] fn __stability () -> & 'static $ T","highlight_start":1,"highlight_end":65},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                __lazy_static_create ! (LAZY, $ T) ; LAZY . get","highlight_start":1,"highlight_end":64},{"text":"                (__static_ref_initialize)","highlight_start":1,"highlight_end":42},{"text":"            } __stability ()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } impl $ crate :: LazyStatic for $ N","highlight_start":1,"highlight_end":41},{"text":"    { fn initialize (lazy : & Self) { let _ = & * * lazy ; } }","highlight_start":1,"highlight_end":63},{"text":"} ; (@ MAKE TY, $ (# [$ attr : meta]) *, ($ ($ vis : tt) *), $ N : ident) =>","highlight_start":1,"highlight_end":77},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    # [allow (missing_copy_implementations)] # [allow (non_camel_case_types)]","highlight_start":1,"highlight_end":78},{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":1,"highlight_end":66},{"text":"    { __private_field : () } # [doc (hidden)] $ ($ vis) * static $ N : $ N = $","highlight_start":1,"highlight_end":79},{"text":"    N { __private_field : () } ;","highlight_start":1,"highlight_end":33},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"__lazy_static_internal!","def_site_span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":0,"byte_end":1201,"line_start":1,"line_end":28,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ($ ($ vis : tt) *) static ref $ N : ident : $ T : ty","highlight_start":1,"highlight_end":78},{"text":" = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":1,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":73},{"text":"    ($ ($ t) *) ;","highlight_start":1,"highlight_end":18},{"text":"} ; (@ TAIL, $ N : ident : $ T : ty = $ e : expr) =>","highlight_start":1,"highlight_end":53},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    impl $ crate :: __Deref for $ N","highlight_start":1,"highlight_end":36},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        type Target = $ T ; fn deref (& self) -> & $ T","highlight_start":1,"highlight_end":55},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            # [inline (always)] fn __static_ref_initialize () -> $ T { $ e } #","highlight_start":1,"highlight_end":79},{"text":"            [inline (always)] fn __stability () -> & 'static $ T","highlight_start":1,"highlight_end":65},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                __lazy_static_create ! (LAZY, $ T) ; LAZY . get","highlight_start":1,"highlight_end":64},{"text":"                (__static_ref_initialize)","highlight_start":1,"highlight_end":42},{"text":"            } __stability ()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } impl $ crate :: LazyStatic for $ N","highlight_start":1,"highlight_end":41},{"text":"    { fn initialize (lazy : & Self) { let _ = & * * lazy ; } }","highlight_start":1,"highlight_end":63},{"text":"} ; (@ MAKE TY, $ (# [$ attr : meta]) *, ($ ($ vis : tt) *), $ N : ident) =>","highlight_start":1,"highlight_end":77},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    # [allow (missing_copy_implementations)] # [allow (non_camel_case_types)]","highlight_start":1,"highlight_end":78},{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":1,"highlight_end":66},{"text":"    { __private_field : () } # [doc (hidden)] $ ($ vis) * static $ N : $ N = $","highlight_start":1,"highlight_end":79},{"text":"    N { __private_field : () } ;","highlight_start":1,"highlight_end":33},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\lib.rs","byte_start":2172,"byte_end":2176,"line_start":73,"line_end":73,"column_start":23,"column_end":27,"is_primary":true,"text":[{"text":"    let users = USERS.lock().await;","highlight_start":23,"highlight_end":27}],"label":"method not found in `USERS`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait defines an item `lock`, perhaps you need to implement it:\ncandidate #1: `lock_api::RawMutex`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: no method named `lock` found for struct `USERS` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:73:23\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mlazy_static::lazy_static! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mmethod `lock` not found for this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m73\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    let users = USERS.lock().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `USERS`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is implemented and in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: the following trait defines an item `lock`, perhaps you need to implement it:\u001b[0m\n\u001b[0m           candidate #1: `lock_api::RawMutex`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"no method named `lock` found for struct `USERS` in the current scope","code":{"code":"E0599","explanation":"This error occurs when a method is used on a type which doesn't implement it:\n\nErroneous code example:\n\n```compile_fail,E0599\nstruct Mouth;\n\nlet x = Mouth;\nx.chocolate(); // error: no method named `chocolate` found for type `Mouth`\n               //        in the current scope\n```\n"},"level":"error","spans":[{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":1066,"byte_end":1076,"line_start":25,"line_end":25,"column_start":56,"column_end":66,"is_primary":false,"text":[{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":56,"highlight_end":66}],"label":"method `lock` not found for this","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":119,"byte_end":199,"line_start":4,"line_end":5,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":5,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":6}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::lazy_static::lazy_static macros>","byte_start":100,"byte_end":191,"line_start":4,"line_end":5,"column_start":5,"column_end":67,"is_primary":false,"text":[{"text":"    __lazy_static_internal !","highlight_start":5,"highlight_end":29},{"text":"    ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":67}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src\\lib.rs","byte_start":440,"byte_end":655,"line_start":16,"line_end":19,"column_start":1,"column_end":2,"is_primary":false,"text":[{"text":"lazy_static::lazy_static! {","highlight_start":1,"highlight_end":28},{"text":"    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());","highlight_start":1,"highlight_end":85},{"text":"    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());","highlight_start":1,"highlight_end":101},{"text":"}","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"lazy_static::lazy_static!","def_site_span":{"file_name":"<::lazy_static::lazy_static macros>","byte_start":0,"byte_end":648,"line_start":1,"line_end":19,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * static ref $ N : ident : $ T : ty = $ e : expr ; $","highlight_start":1,"highlight_end":76},{"text":" ($ t : tt) *) =>","highlight_start":1,"highlight_end":18},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * () static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":67},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub static ref $ N : ident : $ T : ty = $ e : expr ;","highlight_start":1,"highlight_end":78},{"text":" $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":20},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub) static ref $ N : $ T = $ e ; $ ($ t) *) ;","highlight_start":1,"highlight_end":70},{"text":"} ;","highlight_start":1,"highlight_end":4},{"text":"($ (# [$ attr : meta]) * pub ($ ($ vis : tt) +) static ref $ N : ident : $ T :","highlight_start":1,"highlight_end":79},{"text":" ty = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":38},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal !","highlight_start":1,"highlight_end":29},{"text":"    ($ (# [$ attr]) * (pub ($ ($ vis) +)) static ref $ N : $ T = $ e ; $ ($ t)","highlight_start":1,"highlight_end":79},{"text":"     *) ;","highlight_start":1,"highlight_end":10},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"__lazy_static_internal!","def_site_span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":0,"byte_end":1201,"line_start":1,"line_end":28,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ($ ($ vis : tt) *) static ref $ N : ident : $ T : ty","highlight_start":1,"highlight_end":78},{"text":" = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":1,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":73},{"text":"    ($ ($ t) *) ;","highlight_start":1,"highlight_end":18},{"text":"} ; (@ TAIL, $ N : ident : $ T : ty = $ e : expr) =>","highlight_start":1,"highlight_end":53},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    impl $ crate :: __Deref for $ N","highlight_start":1,"highlight_end":36},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        type Target = $ T ; fn deref (& self) -> & $ T","highlight_start":1,"highlight_end":55},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            # [inline (always)] fn __static_ref_initialize () -> $ T { $ e } #","highlight_start":1,"highlight_end":79},{"text":"            [inline (always)] fn __stability () -> & 'static $ T","highlight_start":1,"highlight_end":65},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                __lazy_static_create ! (LAZY, $ T) ; LAZY . get","highlight_start":1,"highlight_end":64},{"text":"                (__static_ref_initialize)","highlight_start":1,"highlight_end":42},{"text":"            } __stability ()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } impl $ crate :: LazyStatic for $ N","highlight_start":1,"highlight_end":41},{"text":"    { fn initialize (lazy : & Self) { let _ = & * * lazy ; } }","highlight_start":1,"highlight_end":63},{"text":"} ; (@ MAKE TY, $ (# [$ attr : meta]) *, ($ ($ vis : tt) *), $ N : ident) =>","highlight_start":1,"highlight_end":77},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    # [allow (missing_copy_implementations)] # [allow (non_camel_case_types)]","highlight_start":1,"highlight_end":78},{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":1,"highlight_end":66},{"text":"    { __private_field : () } # [doc (hidden)] $ ($ vis) * static $ N : $ N = $","highlight_start":1,"highlight_end":79},{"text":"    N { __private_field : () } ;","highlight_start":1,"highlight_end":33},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"__lazy_static_internal!","def_site_span":{"file_name":"<::lazy_static::__lazy_static_internal macros>","byte_start":0,"byte_end":1201,"line_start":1,"line_end":28,"column_start":1,"column_end":13,"is_primary":false,"text":[{"text":"($ (# [$ attr : meta]) * ($ ($ vis : tt) *) static ref $ N : ident : $ T : ty","highlight_start":1,"highlight_end":78},{"text":" = $ e : expr ; $ ($ t : tt) *) =>","highlight_start":1,"highlight_end":35},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    __lazy_static_internal ! (@ MAKE TY, $ (# [$ attr]) *, ($ ($ vis) *), $ N)","highlight_start":1,"highlight_end":79},{"text":"    ; __lazy_static_internal ! (@ TAIL, $ N : $ T = $ e) ; lazy_static !","highlight_start":1,"highlight_end":73},{"text":"    ($ ($ t) *) ;","highlight_start":1,"highlight_end":18},{"text":"} ; (@ TAIL, $ N : ident : $ T : ty = $ e : expr) =>","highlight_start":1,"highlight_end":53},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    impl $ crate :: __Deref for $ N","highlight_start":1,"highlight_end":36},{"text":"    {","highlight_start":1,"highlight_end":6},{"text":"        type Target = $ T ; fn deref (& self) -> & $ T","highlight_start":1,"highlight_end":55},{"text":"        {","highlight_start":1,"highlight_end":10},{"text":"            # [inline (always)] fn __static_ref_initialize () -> $ T { $ e } #","highlight_start":1,"highlight_end":79},{"text":"            [inline (always)] fn __stability () -> & 'static $ T","highlight_start":1,"highlight_end":65},{"text":"            {","highlight_start":1,"highlight_end":14},{"text":"                __lazy_static_create ! (LAZY, $ T) ; LAZY . get","highlight_start":1,"highlight_end":64},{"text":"                (__static_ref_initialize)","highlight_start":1,"highlight_end":42},{"text":"            } __stability ()","highlight_start":1,"highlight_end":29},{"text":"        }","highlight_start":1,"highlight_end":10},{"text":"    } impl $ crate :: LazyStatic for $ N","highlight_start":1,"highlight_end":41},{"text":"    { fn initialize (lazy : & Self) { let _ = & * * lazy ; } }","highlight_start":1,"highlight_end":63},{"text":"} ; (@ MAKE TY, $ (# [$ attr : meta]) *, ($ ($ vis : tt) *), $ N : ident) =>","highlight_start":1,"highlight_end":77},{"text":"{","highlight_start":1,"highlight_end":2},{"text":"    # [allow (missing_copy_implementations)] # [allow (non_camel_case_types)]","highlight_start":1,"highlight_end":78},{"text":"    # [allow (dead_code)] $ (# [$ attr]) * $ ($ vis) * struct $ N","highlight_start":1,"highlight_end":66},{"text":"    { __private_field : () } # [doc (hidden)] $ ($ vis) * static $ N : $ N = $","highlight_start":1,"highlight_end":79},{"text":"    N { __private_field : () } ;","highlight_start":1,"highlight_end":33},{"text":"} ; () => ()","highlight_start":1,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src\\lib.rs","byte_start":2503,"byte_end":2507,"line_start":84,"line_end":84,"column_start":27,"column_end":31,"is_primary":true,"text":[{"text":"    let mut users = USERS.lock().await;","highlight_start":27,"highlight_end":31}],"label":"method not found in `USERS`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"items from traits can only be used if the trait is implemented and in scope","code":null,"level":"help","spans":[],"children":[],"rendered":null},{"message":"the following trait defines an item `lock`, perhaps you need to implement it:\ncandidate #1: `lock_api::RawMutex`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0599]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: no method named `lock` found for struct `USERS` in the current scope\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0msrc\\lib.rs:84:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m/\u001b[0m\u001b[0m \u001b[0m\u001b[0mlazy_static::lazy_static! {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    static ref USERS: Mutex<HashMap<UserId, UserData>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    static ref PHOTOS: Mutex<HashMap<UserId, HashMap<PhotoId, Photo>>> = Mutex::new(HashMap::new());\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m19\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m}\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|_-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14mmethod `lock` not found for this\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m84\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m  \u001b[0m\u001b[0m    let mut users = USERS.lock().await;\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mmethod not found in `USERS`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: items from traits can only be used if the trait is implemented and in scope\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: the following trait defines an item `lock`, perhaps you need to implement it:\u001b[0m\n\u001b[0m           candidate #1: `lock_api::RawMutex`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"aborting due to 10 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 10 previous errors\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0412, E0432, E0433, E0599.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0412, E0432, E0433, E0599.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0412`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0412`.\u001b[0m\n"}
